
#### Мастер-класс по архитектуре и паттернам

---

Привет, как слышно?

---

Кто я?
- Программирую с 2014 года
- Основные ЯП: C#, TypeScript, Python
- Работал в ЛК, Skyeng
- Делаю инженерный софт

---

|             |                              |
| ----------- | ---------------------------- |
| 12:00—15:00 | основы проектирования, SOLID |
| 16:00—19:00 | паттерны                     |
|             |                              |

---
### Основы проектирования
- Low coupling, high cohesion
- Separation of Concerns
- Protected Variations

---
### Что такое архитектура

структура ≠ архитектура

---

- **Термин**: "архитектура"
- **Термин**: "архитектурные решения" (architecture decision, AD)

---

Примеры архитектурных решений:
- выбор языка программирования, интерпретатора, движка
- описание моделей и связей между ними
- выбор подхода к построению системы (клиент-серверная архитектура, событийная архитектура, модель-представление-контроллер)
- выбор библиотек и фреймворков
- выбор структуры модулей, папок и файлов

---

Есть готовые решения (шаблоны):
- На наивысшем уровне это *архитектурные шаблоны*, общие подходы к построению систем.
- На среднем: *шаблоны проектирования* (те самые дизайн-паттерны), принципы SOLID и т.п.
- На уровне кода — идиомы языка, алгоритмы (шаблоны вычислений), структуры данных.

---

> Заказчик хочет фронтенд для интернет-магазина. По его словам там уже "половина сделано". Получив доступ к коду, вы видите, что это один большой файл ванильного JS с очень запутанной логикой. Ваши действия?

---

- декомпозиция
- ответственность программных компонент
- связи (архитектурные границы)
- слои

---

здравый смысл → цели → инструменты

---

Как понять, что система спроектирована "хорошо"?

---

Критерии от Кента Бека
- обеспечивает прохождение всех тестов
- не содержит дублирующегося кода
- выражает намерения программиста
- использует минимальное количество классов и методов

---

от Мартина
- код разбит на атомарные части
- легко вносить изменения, при этом требуемое количество правок минимально
- можно расширять функциональность, добавляя новый код и не меняя старый

---

от Крэга Лармана
- полиморфизм
- низкое зацепление, высокая связность
- устойчивость к изменениям

---

от Фаулера
- «Любой дурак может написать код, который будет понятен компьютеру. Хороший программист пишет код, который будет понятен людям»

---
- **Читаемость**
---
- **Поддерживаемость**
---
- **Расширяемость**
---
- **Масштабируемость**
---
- **Тестируемость**
---

- **Читаемость**
- **Поддерживаемость**
- **Расширяемость**
- **Масштабируемость**
- **Тестируемость**

---

### Зацепление и связность

- **Термин**: Зацепление (в другом переводе — "связанность"), coupling
- **Термин**: Связность, cohesion

---
### Разделение ответственностей

Separation of concerns

---

- **Термин**: архитектурные границы.
- **Термин**: интерфейс.

---

- **задача SoC** — упростить создание систем, представив сложные структуры в виде композиции простых элементов.
- **способ решения** — объединение связанных данных и задач в группы и выделение модулей по одному на каждую группу.

---

Уровни ответственностей

---

Сколько ответственностей у руля?

---

Назначение ответственности компонентам — задача разработчика/архитектора.

---

Инструменты назначения ответственности
- LoD
- GRASP
- MVC/MVP/MVVM

---

### GRASP

General Responsibility Assignment Software Patterns

---
### Закон Деметры

---

"Управлять ногами собаки"

---
### Борьба с лишним кодом

---

DRY — не про копи-паст кода, а про дублирование ответственности.
Ещё хуже, когда *разный* код делает одно и то же.

---

- **задача DRY** поддерживать консистентность применения бизнес-правил
- **Термин**: логика предметной области или "бизнес-логика"

---

YAGNI, KISS

---

### Сценарий проектирования

---

- выделение задач и ролей
- выделение интерфейсов
- выбор связей и взаимодействий

---

декомпозиция → именование → композиция

---

### Как продать проектирование

---

Типичная проблема:
- Сначала было описано одним образом
- Реализовали как описано
- Потом оказалось, что нужно что-то ещё что не учли сначала, или вообще другое

---

Кто виноват?

---

> Мы не можем знать, какие изменения потребуются в будущем. Что мы _можем_ как разработчики — это проектировать программную систему так, чтобы можно было легко вносить эти изменения.

---

Когда делать рефакторинг?

---
### перерыв