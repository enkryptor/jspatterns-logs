#+title: Мастер-класс по принципам и шаблонам проектирования
#+author: Виталий Сергеев https://t.me/frontend_fiesta

* Начинаем!

* Организационные вопросы
** Привет, как слышно?
Проверяем микрофон и ждём опоздавших в Зуме.

** Темы сегодняшнего разговора
SOLID, GRASP и дизайн паттерны — что это, зачем, когда нужны, когда не нужны,
применимы ли на фронтенде. Кроме непосредственно разработки
эти темы также часто встречаются на собеседованиях.

** Регламент
|---------------+------------------------|
| 12:00 - 15:00 | Основы проектирования  |
|               | перерыв 10 мин.        |
|               | SOLID                  |
|---------------+------------------------|
| 15:00 - 16:00 | большой перерыв        |
|---------------+------------------------|
| 16:00 - 19:00 | GRASP                  |
|               | перерыв 10 мин.        |
|               | Шаблоны проектирования |
|               | Завершение             |
|---------------+------------------------|

** Кто я?
- Программирую с 2014 года
- Основные ЯП: C#, TypeScript, Python
- Работал в ЛК, Skyeng

** Кто здесь?
Знакомимся.

* Определимся с понятиями
Цели интенсива. "Хороший" и "плохой" код.

** Пример для разгона
/Заказчик хочет фронтенд для интернет-магазина. По его словам там
/уже /"половина сделано". Получив доступ к коду, вы видите, что это/
/один большой файл ванильного JS с очень запутанной логикой./
/Ваши действия?/

** Знакомые принципы
Универсальный арсенал разработчика (от простого к сложному):
- декомпозиция :: Делим одну комплексную задачу на несколько простых
- разделение ответственностей :: Делим код на части по решаемым задачам
- архитектурные границы :: Устанавливаем связи между частями, проектируем интерфейсы
- архитектурные слои :: Следим за направлением связей

** Принципы - это не более чем инструменты
Это не правила написания хорошего кода. Практика показывает, что механическое
следование SOLID не делает код лучше автоматически, а наоборот, запутывает его.
*** Почему?
Здравый смысл \rarr цели \rarr инструменты.
Надо понимать цель, чтобы оценить,
ведут ли к ней предпринимаемые действия.
Переход от догматизма к рациональности.
*** Не правила, а закономерности
Программирование по большей части - это эмпирическая сфера деятельности.
Следование принципам имеет смысл только в контексте совместной работы.
*** Тем не менее, качество проектирования можно оценить
Каждый хороший подход хорош по-своему, плохие же похожи друг на друга.
Системный подход помогает избегать типовых проблем.
Ограничения приводят к гибкости.

** Собираем метрики
*** Что можно посчитать
- Количество кода
- Покрытие тестами
- Цикломатическая сложность
- "Response For a Class" (кол-во открытых методов)
- Fan-in/Fan-out
  - кол-во классов, которые используют данный класс
  - сколько классов использует он сам
- Следование правилам Code Style, линтинг

*** Что это даст
- QC≠QA или почему KPI не работает
** Ищем критерии
Что говорят классики
*** Кент Бек
- обеспечивает прохождение всех тестов
- не содержит дублирующегося кода
- выражает намерения программиста
- использует минимальное количество классов и методов
*** Крэг Ларман
- устойчивость к изменениям
- низкое зацепление, высокая связность
- полиморфизм
*** Роберт Мартин
- легко вносить изменения, при этом требуемое количество правок минимально
- можно расширять функциональность, добавляя новый код и не меняя старый
- Предлагаются конкретные решения ("чистый код", "чистая архитектура", SAP и т.д.)
*** Фаулер
- «Любой дурак может написать код, который будет понятен компьютеру.
  Хороший программист пишет код, который будет понятен людям»

*** Резюме
Как понять, что система спроектирована "хорошо"?
**** Читаемость
**** Поддерживаемость
**** Расширяемость
**** Масштабируемость
**** Тестируемость
** Вопросы и комментарии

* Основы проектирования

** Архитектура
структура ≠ архитектура
*** Определение
Комплекс важнейших решений об организации системы.
"Важнейшие" это как правило те, которые мы не сможем легко поменять в будущем.

*** Примеры архитектурных решений (ADR, architecture decision record)
- выбор языка программирования, интерпретатора, движка
- выбор подхода к построению системы (событийная архитектура, модель-представление-контроллер)
- выбор библиотек и фреймворков
- настройка процессов
- описание моделей (абстракций) и связей между ними
- назначение ответственности программных компонент
- выбор структуры модулей, папок и файлов

*** Масштаб
Модель C4. Первый шаг для освоения архитектуры "снизу вверх".
- Context (цели, процессы, требования)
- Container (приложения)
- Component (~модули)
- Code (классы, интерфейсы, функции, модели данных)

** Типовые проблемы
Архитектурные идеи касаются "решений, которые мы не сможем поменять".
Но почему вообще возникает необходимость что-то менять?

- Сначала было описано одним образом
- Реализовали как описано
- Потом оказалось, что требования не были полными, и нужно что-то другое

*** Кто виноват?
*** Что делать?
Мы не можем знать, какие изменения потребуются в будущем. Что мы можем как
разработчики — это проектировать программную систему так, чтобы можно было
легко вносить эти изменения.

** Шаблоны и принципы
Принципы - готовые подходы к решению, шаблоны - готовые решения.
- На высоком уровне это *архитектурные шаблоны*
- На среднем: *шаблоны проектирования* (те самые дизайн-паттерны), принципы SOLID и т.п.
- На уровне кода — идиомы языка, алгоритмы (шаблоны вычислений), структуры данных.

** Разделение ответственностей
Separation of concerns

декомпозиция -> именование -> композиция

*** Низкое зацепление, высокая связность
Low coupling, high cohesion

Свойство программного компонента (модуля, класса, функции)

- связность (cohesion) ::
  сфокусированность программного компонента на решаемой задаче

- зацепление (coupling) ::
  зависимость его от других компонент

*** Уровни ответственности
- Приложение
- Модуль
- Класс
- Метод
- Локальная переменная

*** Сколько ответственностей у руля?
**** Проектируем модуль "Кабина"
#+begin_src typescript
class Accelerator {
    accelerate()
}

class Break {
    decelerate()
}

class SteeringWheel {
    turnRight()
    turnLeft()
}
#+end_src
**** Одна ответственность - один метод?
#+begin_src typescript
class RightLever {
    turnRight()
}

class LeftLever {
    turnLeft()
}
#+end_src
**** Зачем вообще нам несколько классов?
#+begin_src typescript
class Joystick {
    accelerate()
    decelerate()
    turnRight()
    turnLeft()
}
#+end_src
*** Инструменты назначения ответственности
Назначение ответственности компонентам — задача разработчика/архитектора.
Большинство шаблонов и подходов так или иначе решают именно эту задачу.

** Закон Деметры
Law of Demeter (LoD)
*** Что это
Подход, регламентирующий взаимодействие программных модулей
"Не разговаривай с незнакомцами"
*** Как нарушается
Лишние зависимости
Обращение "через голову" к другому модулю
В интерфейс проникают посторонние элементы
либо работа идёт с реализацией в обход интерфейса
("управлять ногами собаки")
*** Чем это плохо
Хрупкий код - правки в реализации ломают неявные зависимости

** Борьба с лишним кодом
*** DRY (don't repeat yourself)
**** Что значит принцип
DRY это не про одинаковый код в разных местах.
Намного хуже, если разный код делает одно и то же.
**** Какую проблему решает
Консистентность применения бизнес-правил.
Неверно выделенная абстракция обходится дороже дублирования.
В некоторых случаях малоприменимо (например, в тестах).
DAMP - "descriptive and meaningful phrases".

*** YAGNI (you aren't gonna need it)
Отказ от избыточной функциональности.

*** KISS (keep it simple)
Писать простой код - это сложно.

*** Мёртвый код
Не оставляйте код, который не будет выполняться.

*** Избыточный код
Всё, без чего можно было бы обойтись.
- "Велосипеды" - специальные решения типовых задач
- Нарушение идиоматичности
- Комплексность как следствие поэтапной разработки

** Вопросы и комментарии

* Перерыв 10 минут

* Принципы SOLID
Почему это не так просто, как кажется на первый взгляд.

** Принцип единственной ответственности
Single Responsibility Principle (SRP)

*** Формулировки
- "Класс должен делать что-то одно." (популярная но неправильная)
- "Класс должен иметь одну и только одну причину для изменения." (из ЧК)
- "Модуль должен отвечать перед одним и только одним актором." (из ЧА)

*** Зачем нужен
- улучшает читаемость кода
- упрощает внесение изменений
- позволяет изолировать тесты
- логично следует из принципа SoC

*** Сложности применения
- Назначение ответственности - непростая задача
- Неверно выделенная абстракция обходится дороже
- Вариант для UI - данные и представление (диаграмма)

** Принцип открытости-закрытости
Open-closed principle (OCP)

*** Формулировка

"Software entities (classes, modules, functions, etc.) should be
open for extension, but closed for modification" (Bertrand Meyer)

"Программные сущности (классы, модули, функции и т.п.) должны быть
открыты для расширения, но закрыты для изменения".

*** Зачем нужен

Чтобы новые фичи не ломали старые. Мы только дописываем код,
и не трогаем то, что уже работает и протестировано.

*** Варианты
**** по Мартину (классический из ООП)
Расширение через наследование. Пример.
**** по Мейеру
Дополнение, но не изменение интерфейсов.

*** Сложности применения
Требует выделять абстракции, что само по себе непросто.
Из-за стремления не менять интерфейс в коде накапливаются другие неудачные решения
(например, параметры-флаги).

*** Пример задачи с собеседования
Напишите функцию, считающую среднее из двух чисел.
Теперь сделайте из неё функцию, принимающую три числа.

В чём сложность:
Просьбы добавить параметры могут продолжаться в будущем.
Реализация новых сценариев не должна ломать старые.

** Принцип подстановки Лисков
Liskov substitution principle (LSP)

*** Формулировка

 "A particular definition of a subtyping relation, called strong behavioral subtyping — an object may be replaced by a sub-object without breaking the program."

«Объект может быть заменён на подтип без нарушения логики программы».

*** Зачем нужен
Уменьшает риски того, что сломанный код выглядит правильным.

*** Сложности применения
- Сильно завязан на парадигму ООП.
- На фронтенде чаще встречается не сколько нарушение LSP,
  сколько нецелевое применение наследования.
- Примеры.

** Принцип разделения интерфейсов
Interface Segregation Principle (ISP)

*** Формулировка

"A class should not be forced to implement methods it doesn't need"

Клиенты не должны вынуждено зависеть от методов, которыми не пользуются.

*** Зачем нужен
Позволяет снизить расходы на реализацию.

*** Сложности применения
- Не так актуален в TypeScript.
- Чаще встречаются избыточные, а не комбинированные интерфейсы.

** Принцип инверсии зависимостей
Dependency Inversion Principle (DIP)

*** Формулировка

"High-level modules should not depend on low-level modules. Both should depend
on abstractions. Abstractions should not depend on details, but details should
depend on abstractions."

- Модули верхних уровней не должны зависеть от модулей нижних уровней. Оба типа
  модулей должны зависеть от абстракций.
- Абстракции не должны зависеть от деталей. Детали должны зависеть
  от абстракций.

*** Зачем нужен
Позволяет улучшить переиспользование, заменяемость и тестируемость.

*** Сложности применения
- Для полноценного применения нужен DI-контейнер (фреймворк).
- Не так актуален для динамических языков, т.к. в таких языках
  работа всегда идёт с интерфейсом, а не с реализацией.

** Вопросы, комментарии
Какие примеры применения (или нарушения) SOLID
вы встречали в своей практике?

* Большой перерыв

* Принципы GRASP
General Responsibility Assignment Software Patterns/Principles

** Перечень шаблонов
Как их можно встретить в литературе

1. Информационный эксперт (Information Expert)
2. Создатель (Creator)
3. Контроллер (Controller)
4. Слабое (низкое) зацепление (Low Coupling)
5. Сильная (высокая) связность (High Cohesion)
6. Полиморфизм (Polymorphism)
7. Чистая выдумка (Pure Fabrication)
8. Перенаправление (Indirection)
9. Устойчивость к изменениям (Protected Variations)

** Классифицируем
*** Роли
1. Информационный эксперт (Information Expert)
2. Создатель (Creator)
3. Контроллер (Controller)
4. Чистая выдумка (Pure Fabrication)
5. Перенаправление (Indirection)

*** Принципы
1. Слабое (низкое) зацепление (Low Coupling)
2. Сильная (высокая) связность (High Cohesion)
3. Полиморфизм (Polymorphism)

*** Свойство системы
1. Устойчивость к изменениям (Protected Variations)

** Пример

* Важность прагматизма
Ориентируемся на цели. Что необходимо знать разработчику и зачем?

** Типовые ошибки
*** Усложенение, а не упрощение кода
В чём суть работы программиста?

*** Усложнение системы - лишние абстракции
- "Любую проблему проектирования можно решить
  добавлением новой абстракции, кроме проблемы
  наличия лишних абстракций".
- Иногда простое дублирование кода обойдётся дешевле.
- Важно разделять контракт и реализацию.
- Неверно выделенные абстракции.
  - Проблема неправильного разделения ответственности
    может быть усугублена через наследование.
  - Пример, параллели с DRY.

*** Усложнение системы - кривые зависимости
- Циклические зависимости
- Зависимость от своего или нижнего уровня
- Зависимость от деталей реализации
- Неявные зависимости, разные виды зацепления

** Чем помогут шаблоны
- проверенные решения, ориентированные на расширяемость кода
- готовые решения позволяют сэкономить время
- стандартизация кода улучшает читаемость

** Чем вредны шаблоны
- Применение любого паттерна ограничено решением конкретной задачи.
  Дрелью можно забить гвоздь, но нужна она для другого.

По мнению Стива Макконнелла, с применением шаблонов могут быть связаны две
сложности. Во-первых, слепое следование некоторому выбранному шаблону может
привести к усложнению программы. Во-вторых, у разработчика может возникнуть
желание попробовать некоторый шаблон в деле без особых оснований.

** Этапы понимания шаблонов
Таксономия Блума: знание, понимание, применение, анализ, оценка, создание.

1. Выучить паттерны, знать определение.
2. Видеть их применение в чужом коде.
3. Уметь применить самому.
4. Уметь анализировать и оценить уместность применения.

"Применение" это не только написание кода по шаблонам, но и понимание
и использование такого кода (напр. библиотечные вызовы). Понимание
принципов сильно помогает в освоении конкретики (фреймворков и т.п.)

* Поведенческие шаблоны

** Стратегия
*** Задача
Требуется изменение части алгоритма, которое либо невозможно,
либо приведёт к излишней запутанности.
*** Решение
Определить семейство схожих алгоритмов и поместить каждый из них
в собственный класс, после чего передавать этот класс снаружи.
*** Примеры

** Итератор
*** Задача
Перебрать коллекцию элементов, которая организована
в сложном (или неизвестном) порядке.
*** Решение
Вынести поведение обхода коллекции из самой коллекции
в отдельный класс
*** Пример

** Шаблонный метод
Template method
*** Задача
Упростить сложный код, выполняющий те или иные действия
в зависимости от условий.
*** Решение
Перенести управление потоком выполнения из кода в данные.
Разбить алгоритм на шаги, выделить шаги в методы и вызывать их
в одном (т.н. "шаблонном") методе друг за другом.
В наследниках перекрыть конкретные шаги.
*** Пример

** Наблюдатель
(Observer, Listener/Слушатель, Издатель-Подписчик)

*** Задача
Обеспечить реактивное поведение на изменение состояния другого объекта,
не вызывая необходимости напрямую следить за этим состоянием.
*** Решение
Отдельный компонент, ответственный за взаимодействие (шина).
Создаём механизм подписки, позволяющий одним объектам следить
и реагировать на события, порождаемые другими объектами.
*** Примеры
- ~store.subscribe(listener)~ в Redux
- rxjs
- MobX
- ~EventTarget.addEventListener()~

** Посредник
*** Задача
Объекты должны взаимодействовать друг с другом,
но мы не хотим прописывать эту логику в них.
*** Решение
Добавить отдельный компонент, отвечающий за сценарии взаимодействия.
Часто можно встретить в комбинации с подпиской.
*** Пример

** Команда
*** Задача
Работать с действием как с данными
(передать в параметр, положить в очередь и т.п.)
*** Решение
Превратить действие в объект.
*** Пример

** Цепочка обязанностей
Chain of responsibility
*** Задача
Выбрать нужный способ обработки запроса.
*** Решение
Передаём запрос по цепочке обработчиков.
Пусть обработчики сами знают, в каких случаях они применимы.
*** Пример

** Состояние
Позволяет объектам менять поведение в зависимости от своих данных.

* Перерыв 10 минут

* Порождающие шаблоны
** Фабрика
*** Задача
Коду-потребителю нужен объект определённого вида или произвольное количество
объектов, но мы заранее не знаем, какое.
*** Решение
Передать потребителю функцию создания объекта вместо самого объекта.

** Фабричный метод
Решает задачу переусложнённого конструктора, заменяя
один универсальный конструктор на несколько разных методов.

** Одиночка
*** Задача
Дать глобальную точку доступа к объекту и при этом гарантировать,
что экземпляр будет единственным.
*** Решение
Предоставить статический метод, возвращающий экземпляр объекта.
*** Пример

** Строитель
Позволяет создавать сложные объекты.
*** Пример из angular/forms

** Прототип
Позволяет копировать объекты, не вдаваясь
в подробности их реализации.
*** Пример

* Структурные шаблоны
** Декоратор
*** Задача
Модифицировать класс, когда трогать его нельзя,
и наследование по той или иной причине не подходит.
*** Решение
Заменить наследование агрегацией.
*** Примеры

** Fluent interface
*** Задача
Улучшение читаемости последовательных вызовов методов.
*** Решение
Оформить в виде цепочки методов в одном контексте.

** Конвейер (pipe/compose)
Объединяет функции в цепочку вызовов.

** Примесь (mixin)
Позволяет модифицировать класс или объект.
*** Сложности использования
- Классический миксин не предполагает наследования!
  Миксины могут наследоваться друг от друга, но
  целевой класс не наследуется от миксинов.
- Однако в TS/JS под миксином могут понимать
  цепочку классов, как бы реализующую множественное наследование.
*** Примеры

** Фасад
*** Задача
Упросить код, которому приходится работать с объектами
со сложным/неудобным интерфейсом.
*** Решение
Внедрить простой интерфейс для работы со сложной подсистемой.

** Адаптер
Позволяет объектам с несовместимыми интерфейсами работать вместе.

** Заместитель
Proxy

Позволяет подставлять вместо реальных объектов специальные
объекты-заменители с дополнительной функциональностью.

** Приспособленец
Lightweight

Позволяет вместить большее количество объектов в отведённый ресурс.

* Завершение
** Вопросы и комментарии

** Как "продать" проектирование?
*** Стремление к качеству кода удорожает разработку.
*** Рефакторинг бесполезен с точки зрения бизнеса.
- М. Фаулер рекомендует закладывать время на рефакторинг в оценку
*** Работа без технического долга невозможна.
- Возникновение техдолга это обычный процесса разработки
- Иногда техдолг это даже хорошо
- Плохо, если мы не знаем, как будем его отдавать
*** ИИ пишет код лучше программистов.
- А значит, тем важнее становится архитектура
- Фронтенд сейчас - это далеко не только веб.

** Материалы вебинара и контакты
- Примеры кода https://github.com/enkryptor/jspatterns-examples
- В личном кабинете будет доступна запись видео
- Все ссылки придут на почту, т.ч. на запись чата и презентацию
- Еженедельный канал в телеграме: https://t.me/frontend_fiesta

** Рекомендуемые книги:
- «Чистая архитектура» Роберт Мартин
- «Приёмы объектно-ориентированного проектирования» Э. Гамма, Р. Хелм,
  Р. Джонсон, Д. Влисидис (т.н. "банда четырёх")
- «Чистый код» Роберт Мартин
- «Применение UML и шаблонов проектирования» К. Ларман
- «Рефакторинг. Улучшение существующего кода» М. Фаулер
- «Рефакторинг кода на JavaScript» Фаулера при участии Кента Бека
- «Экстремальное программирование: разработка через тестирование» Кент Бек
- «Совершенный код» С. Макконнелл
- «Прагматичный программист» Дэвид Томас и Эндрю Хант
- «Код, который умещается в голове» Марк Симан

* Спасибо за внимание!
